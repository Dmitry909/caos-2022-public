## Подпрограммы

Мы хотим переиспользовать код — вызывать
одну и ту же последовательность инструкций из разных
точек программы.

```x86asm
double_eax:
    sal $1, %eax
    jmp ...  // куда?
    

    ...
    jmp double_eax
    // хотим продолжить исполнение здесь

    ...
    jmp double_eax
    // или здесь
```

Некоторые архитектуры решают это с помощью
специального регистра для адреса возврата.
Если бы такой был в x86, подпрограммы могли бы
выглядеть так:
```x86asm
double_eax:
    sal $1, %eax
    jmp *%return_address
    

    ...
    mov $1f, %return_address
    jmp double_eax
1:

    ...
    mov $1f, %return_address
    jmp double_eax
1:
```

Но в x86 принято адрес возврата класть на стек:
```x86asm
double_eax:
    sal $1, %eax
    pop %edx        // достаём из стека адрес возврата
    jmp *%edx       // и переходим по нему
    

    ...
    push $1f        // кладём в стек адрес возврата
                    // (адрес следующей инструкции после jmp)
    jmp double_eax  // и переходим на начало подпрограммы
1:

    ...
    push $1f
    jmp double_eax
1:
```

Для этих операций (вход в подпрограмму и возвращение из неё)
есть специальные инструкции `call` и `ret`:
```x86asm
double_eax:
    sal $1, %eax
    ret             // достаём из стека адрес возврата
                    // и переходим по нему
    

    ...
    call double_eax // кладём в стек адрес возврата
                    // (адрес следующей инструкции после call)
                    // и переходим на начало подпрограммы

    ...
    call double_eax
```

В подпрограмме важно соблюдать баланс инструкций
`push` и `pop`, чтобы не промахнуться мимо адреса возврата.

## Соглашения о вызове

Чтобы разные люди (и компиляторы) могли совместно разрабатывать
подпрограммы, им нужно договориться, как передавать
в подпрограмму параметры, как возвращать результат и какие
регистры подпрограмма не будет портить. Такие договорённости
называются *соглашениями о вызовах* (calling conventions).

