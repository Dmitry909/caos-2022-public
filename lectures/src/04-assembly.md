# Язык ассемблера

## Наш подопытный кролик — x86
![](./ibm-pc.webp)
Компьютер IBM PC, выпущенный в 1981 году, оснащался процессором
Intel 8088, а более поздние модели — процессорами
80286, 80386 и 80486.

## Машинный код и язык ассемблера
Читать инструкции процессора в виде чисел очень неудобно (а писать тем более):
```
    2c93:       48 8d 91 00 00 fe ff
    2c9a:       48 39 c2 
    2c9d:       b8 00 00 02 00
    2ca2:       48 0f 46 c1
```

Поэтому для инструкций придумывают названия (мнемоники) и правила записи
их операндов, а потом делают
конвертор из такого текстового представления в двоичное (машинный код).
Такой конвертор называется ассемблером, а текстовое представление инструкций — языком ассемблера.

```
    lea    -0x20000(%rcx),%rdx
    cmp    %rax,%rdx
    mov    $0x20000,%eax
    cmovbe %rcx,%rax
```

## Регистры
«Переменные» внутри процессора.

Instruction pointer (program counter): `eip`.

Регистры общего назначения (general purpose registers):

| Регистр | Младшие 16 бит | Два младших байта |
|---------|----------------|-------------------|
`eax` | `ax` | `ah`, `al`
`ebx` | `bx` | `bh`, `bl`
`ecx` | `cx` | `ch`, `cl`
`edx` | `dx` | `dh`, `dl`
`esi` | `si` | —, `sil`
`edi` | `di` | —, `dil`
`ebp` | `bp` | —, `bpl`

(Есть ещё регистр `esp`, который мы пока не трогаем.)

## Первые инструкции
Инструкция выглядит примерно так: `мнемоника операнд, операнд`.

Операнд-регистр записывается после знака процента: `%eax`.

Наша первая мнемоника: `mov`.
```
mov SRC, DST   // копировать SRC в DST
mov %eax, %ebx // скопировать биты eax в ebx
               // старое значение ebx теряется
```
Справочник: [https://www.felixcloutier.com/x86/mov]()

Список инструкций: [https://www.felixcloutier.com/x86/index.html]()

Непосредственно заданный операнд:
```
mov $42, %ecx   // положить в %ecx битовое представление числа 42

mov $0x80, %edx // шестнадцатеричная запись операнда
mov $-1, %eax   // установить все биты eax в 1
```

## Библиотека simpleio
```
call writei32   // напечатать на экране значение eax
                // как знаковое десятичное число
call readi32    // ввести с клавиатуры число и сохранить в eax
call finish     // завершить исполнение программы
```

Наша первая программа на языке ассемблера x86, вычисляющая сумму двух чисел:
```
    .global main
main:
    call readi32     // считали первое число
    mov %eax, %ecx   // сохранили его в ecx
    call readi32     // считали второе число в eax
    add %ecx, %eax   // сложили первое и второе
    call writei32    // вывели результат
    call finish      // завершили программу
```

Сохраним её в файл `sum.S` (да, заглавная S), оттранслируем и запустим:

```sh
$ gcc -m32 -g sum.S simpleio_i686.S -o sum
$ ./sum
```

## Некоторые арифметические инструкции

```
add SRC, DST
sub SRC, DST
inc DST
dec DST
```
